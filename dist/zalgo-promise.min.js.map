{"version":3,"sources":["webpack://ZalgoPromise/webpack/universalModuleDefinition","webpack://ZalgoPromise/webpack/bootstrap","webpack://ZalgoPromise/./src/utils.ts","webpack://ZalgoPromise/./src/exceptions.ts","webpack://ZalgoPromise/./src/flush.ts","webpack://ZalgoPromise/./src/promise.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","hasOwnProperty","p","s","isPromise","item","Promise","window","Window","constructor","toString","then","err","flushPromise","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","resolved","rejected","errorHandled","error","handlers","dispatching","stack","result","isAsync","res","reject","Error","dispatch","setTimeout","indexOf","push","j","length","dispatchPossiblyUnhandledError","asyncReject","chain","firstPromise","secondPromise","onSuccess","onError","catch","undefined","finally","onFinally","try","timeout","time","clearTimeout","toPromise","TypeError","all","promises","count","results","prom","hash","awaitPromises","map","items","method","onPossiblyUnhandledException","cancel","splice","context","args","apply","delay","flush"],"mappings":"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","file":"zalgo-promise.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ZalgoPromise\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZalgoPromise\"] = factory();\n\telse\n\t\troot[\"ZalgoPromise\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export function isPromise(item: unknown): boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (\n            typeof window !== 'undefined' &&\n            typeof window.Window === 'function' &&\n            item instanceof window.Window\n        ) {\n            return false;\n        }\n\n        if (\n            typeof window !== 'undefined' &&\n            typeof window.constructor === 'function' &&\n            item instanceof window.constructor\n        ) {\n            return false;\n        }\n\n        const toString = {}.toString;\n\n        if (toString) {\n            const name = toString.call(item);\n\n            if (\n                name === '[object Window]' ||\n                name === '[object global]' ||\n                name === '[object DOMWindow]'\n            ) {\n                return false;\n            }\n        }\n\n        if (typeof (item as { then: any }).then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n","import type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors: Error[] = [];\nconst possiblyUnhandledPromiseHandlers: Array<\n    (arg0: unknown, promise?: ZalgoPromise<unknown>) => void\n> = [];\nexport function dispatchPossiblyUnhandledError<T>(\n    err: Error,\n    promise: ZalgoPromise<T>\n): void {\n    // @ts-ignore\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    // @ts-ignore\n    dispatchedErrors.push(err);\n    setTimeout(() => {\n        // @ts-ignore\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(\n                `${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${\n                    promise.stack\n                }`\n            );\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // @ts-ignore\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\nexport function onPossiblyUnhandledException(\n    handler: (arg0: unknown, promise?: ZalgoPromise<unknown>) => void\n): {\n    cancel: () => void;\n} {\n    possiblyUnhandledPromiseHandlers.push(handler);\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(\n                possiblyUnhandledPromiseHandlers.indexOf(handler),\n                1\n            );\n        }\n    };\n}\n","import type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise: ZalgoPromise<void> | null;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive(): void {\n    activeCount += 1;\n}\nexport function endActive(): void {\n    activeCount -= 1;\n    flushActive();\n}\nexport function awaitActive(Zalgo: ZalgoPromise<any>): ZalgoPromise<void> {\n    // @ts-ignore\n    const promise = (flushPromise = flushPromise || new Zalgo());\n    flushActive();\n    return promise;\n}\n","import { isPromise } from './utils';\nimport {\n    onPossiblyUnhandledException,\n    dispatchPossiblyUnhandledError\n} from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R extends unknown> {\n    resolved: boolean;\n    rejected: boolean;\n    errorHandled: boolean;\n    value?: R;\n    error: unknown;\n    handlers: Array<{\n        promise: ZalgoPromise<any>;\n        onSuccess: void | ((result: R) => unknown);\n        onError: void | ((error: unknown) => unknown);\n    }>;\n    dispatching?: boolean;\n    stack?: string;\n\n    constructor(\n        handler?: (\n            resolve: (result: R) => void,\n            reject: (error: unknown) => void\n        ) => void\n    ) {\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n        this.handlers = [];\n\n        if (handler) {\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n            startActive();\n\n            try {\n                handler(\n                    (res) => {\n                        if (isAsync) {\n                            this.resolve(res);\n                        } else {\n                            resolved = true;\n                            result = res;\n                        }\n                    },\n                    (err) => {\n                        if (isAsync) {\n                            this.reject(err);\n                        } else {\n                            rejected = true;\n                            error = err;\n                        }\n                    }\n                );\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n            isAsync = true;\n\n            if (resolved) {\n                // @ts-ignore - potentially undefined\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        // @ts-ignore\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result?: R): ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n        return this;\n    }\n\n    reject(error: unknown): ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            const err =\n                // @ts-ignore\n                error && typeof error.toString === 'function'\n                    ? // @ts-ignore\n                    error.toString()\n                    : Object.prototype.toString.call(error);\n            error = new Error(\n                `Expected reject to be called with Error, got ${ err }`\n            );\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    // @ts-ignore\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n        return this;\n    }\n\n    asyncReject(error: unknown): ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n\n    dispatch(): void {\n        const { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(\n            firstPromise: ZalgoPromise<T>,\n            secondPromise: ZalgoPromise<T>\n        ) => {\n            return firstPromise.then(\n                (res) => {\n                    secondPromise.resolve(res);\n                },\n                (err) => {\n                    secondPromise.reject(err);\n                }\n            );\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n            const { onSuccess, onError, promise } = handlers[i];\n            let result;\n\n            if (resolved) {\n                try {\n                    // @ts-ignore\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            } else if (rejected) {\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (\n                result instanceof ZalgoPromise &&\n                (result.resolved || result.rejected)\n            ) {\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n            } else if (isPromise(result)) {\n                if (\n                    result instanceof ZalgoPromise &&\n                    (result.resolved || result.rejected)\n                ) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n                } else {\n                    // @ts-ignore\n                    chain(result, promise);\n                }\n            } else {\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X extends unknown, Y extends unknown>(\n        onSuccess: void | ((result: R) => ZalgoPromise<X> | Y),\n        onError: void | ((error: unknown) => ZalgoPromise<X> | Y)\n    ): ZalgoPromise<X | Y> {\n        // @ts-ignore\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error(\n                'Promise.then expected a function for success handler'\n            );\n        }\n\n        // @ts-ignore\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error(\n                'Promise.then expected a function for error handler'\n            );\n        }\n\n        // @ts-ignore\n        const promise: ZalgoPromise<X | Y> = new ZalgoPromise();\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n        this.errorHandled = true;\n        this.dispatch();\n        return promise;\n    }\n\n    catch<X extends unknown, Y extends unknown>(\n        onError: (error: unknown) => ZalgoPromise<X> | Y\n    ): ZalgoPromise<X | Y> {\n        return this.then(undefined, onError);\n    }\n\n    finally(onFinally: () => unknown): ZalgoPromise<R> {\n        // @ts-ignore\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        // @ts-ignore - doesn't match ZalgoPromise<R>\n        return this.then(\n            (result) => {\n                return ZalgoPromise.try(onFinally).then(() => {\n                    return result;\n                });\n            },\n            (err) => {\n                return ZalgoPromise.try(onFinally).then(() => {\n                    throw err;\n                });\n            }\n        );\n    }\n\n    timeout(time: number, err: Error | null | undefined): ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        const timeout = setTimeout(() => {\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n        }, time);\n        return this.then((result) => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    toPromise(): Promise<R> {\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n\n        // @ts-ignore\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    static resolve<X extends unknown>(\n        value?: X | ZalgoPromise<X>\n    ): ZalgoPromise<X> {\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            return new ZalgoPromise((resolve, reject) =>\n                // @ts-ignore is it a promise or a value who knows\n                value.then(resolve, reject));\n        }\n\n        // @ts-ignore is it a promise or a value who knows\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error: unknown): ZalgoPromise<unknown> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error: unknown): ZalgoPromise<unknown> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X extends ReadonlyArray<unknown>>(\n        promises: X\n    ): ZalgoPromise<unknown> {\n        const promise = new ZalgoPromise();\n        let count = promises.length;\n        const results: Array<unknown> = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(\n            i: number,\n            firstPromise: ZalgoPromise<T>,\n            secondPromise: ZalgoPromise<T>\n        ) => {\n            return firstPromise.then(\n                (res) => {\n                    results[i] = res;\n                    count -= 1;\n\n                    if (count === 0) {\n                        promise.resolve(results);\n                    }\n                },\n                (err) => {\n                    secondPromise.reject(err);\n                }\n            );\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            const prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O extends Record<string, any>>(promises: O): ZalgoPromise<any> {\n        const result = {};\n        const awaitPromises = [];\n\n        for (const key in promises) {\n            if (promises.hasOwnProperty(key)) {\n                const value = promises[key];\n\n                if (isPromise(value)) {\n                    awaitPromises.push(\n                        // @ts-ignore\n                        value.then((res) => {\n                            // @ts-ignore\n                            result[key] = res;\n                        })\n                    );\n                } else {\n                    // @ts-ignore\n                    result[key] = value;\n                }\n            }\n        }\n\n        return ZalgoPromise.all(awaitPromises).then(() => result);\n    }\n\n    static map<T, X>(\n        items: ReadonlyArray<T>,\n        method: (arg0: T) => ZalgoPromise<X> | X\n    ): ZalgoPromise<ReadonlyArray<X>> {\n        // @ts-ignore\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler: (err: unknown) => void): {\n        cancel: () => void;\n    } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<\n        X extends unknown,\n        Y extends unknown,\n        C extends unknown,\n        A extends ReadonlyArray<unknown>\n    >(\n        method: (...args: A) => ZalgoPromise<X> | Y,\n        context?: C,\n        args?: A\n    ): ZalgoPromise<X | Y> {\n        // @ts-ignore\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result;\n        startActive();\n\n        try {\n            // @ts-ignore\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            // @ts-ignore\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n        // @ts-ignore\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay: number): ZalgoPromise<void> {\n        return new ZalgoPromise((resolve) => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value: unknown): boolean {\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush(): ZalgoPromise<void> {\n        // @ts-ignore\n        return awaitActive(ZalgoPromise);\n    }\n}\n"],"sourceRoot":""}